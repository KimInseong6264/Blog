
# Big-O 표기법

## 1. 알고리즘

**알고리즘을 설계하는 과정에서 고려해야 할 것이 Big-O 표기법이다.**
**그렇기 때문에 Big-O를 알기 위해선 먼저 알고리즘에 대해 먼저 알아야 한다.**


### 1) 알고리즘의 개념

![](https://velog.velcdn.com/images/iissk/post/8c5e944b-d800-44cd-b9e9-c6b208537a3a/image.PNG)

알고리즘의 예시: **라면 조리법**

1. 라면을 끓일 냄비, 조리 도구를 준비
2. 냄비에 물을 넣고 끓인다.
3. 물이 끓으면 면과 스프, 계란을 넣고 3분동안 끓인다.
4. 완성된 라면을 return 한다.

위의 예시처럼 라면을 끓이는 일련의 과정처럼,
<br>
**문제를 해결**하기 위해 **단계적**으로 풀어나가는 **풀이 과정**이라고 할 수 있다.

### 2) 알고리즘 설계 핵심

**알고리즘을 설계할 때, 중요한 것은 총 3가지이다.**

![](https://velog.velcdn.com/images/iissk/post/dafb3d75-2284-417b-a754-d8d999d34f3c/image.png)


1. **가독성:** 문제 해결을 위한 코드인데, 코드 읽는 것부터 문제가 되면 안 된다.
2. **확장성:** 만들어진 알고리즘은 언제든 수정, 보완이 되어야 한다.
3. **효율성:** 한 세월 걸려서 문제를 해결하면 그건 오히려 고문이다...

#### ∴ 여기서 우리는 효율성 판단을 위해서 Big-O 표기법을 사용하는 것이다.

<br>

## 2. Big-O 표기법

**알고리즘의 효율성을 따질 때는 시간 복잡도(Time Complexity)와 공간 복잡도(pace Complexity)를 고려한다.**

1. **시간 복잡도:** 알고리즘을 사용할 때 들어가는 시간적 비용, 얼마나 빨리 계산할 수 있는지를 의미
2. **공간 복잡도:** 알고리즘에서 사용하는 메모리의 양, 얼마나 적은 공간에서 계산하는지를 의미
<br>
공간 복잡도는 물리적인 한계(하드웨어의 저장공간)가 있어, 주로 알고리즘은 시간 복잡도를 중심으로 효율성을 개선

#### ∴ 시간 복잡도를 표시하는 표기법이 Big-O인 것이다.

### 1) 시간 복잡도(Time Complexity)

![](https://velog.velcdn.com/images/iissk/post/5817a5f3-d792-4dc2-99ec-e7b707ca7aeb/image.png)


시간 복잡도는 위의 3가지의 방식으로 판단을 할 수 있다.
<br>
하지만 프로그래밍에서 중요한 것은 **안정성**이다.
<br>
즉, 최악의 상황을 기준으로 판단했을 때, 안정적인 관리가 가능하다.
<br>
왜 **Big-O**의 **O**가 의미하는 것이 바로 이것이다.

### 2) Big-O 그래프

![](https://velog.velcdn.com/images/iissk/post/0c9ecbb5-6a4f-4117-8a37-e5f88ac0c710/image.PNG)

위의 그림에서와 같이 O( )과 같은 형식으로 표현을 하고 ( ) 안의 값에 따라 시간 복잡도가 달라지는 것을 알 수 있다.

> #### 시간 복잡도의 빠른 정도
> 1 < log < n < 다항함수 < 지수함수 < !(팩토리얼)

<br>

## 3. Big-O의 종류

### 1) O(1)

![](https://velog.velcdn.com/images/iissk/post/ba3ac33b-fc2e-415a-afbb-c5c203a762a9/image.PNG)

O(1)은 반복문이 없는 것으로 생각하면 쉽다. 기본적인 코드 작성들은 O(1)임을 알 수 있다.
<br>
빠르다는 것을 의미한다기 보다는 **비용 없이 사용이 가능하다**는 의미라고 생각하면 된다.

### 2) O(n)

![](https://velog.velcdn.com/images/iissk/post/3f482bd1-e70d-4ff6-b901-b360bfcbd087/image.png)

반복문 중첩없이 사용되는 것을 O(n)이라고 한다.
<br>
위의 그림과 같이 O(2n)으로 쓰지 않고 O(n)으로 쓰지 않는 이유는
<br>
O는 최악을 상정한다고 했기 때문에, **n이 ∞이 되는 것을 기준**으로 생각하면 된다.
<br>
따라서 2n이나 n이나 무한으로 증가하기 때문에 n으로 **표기한다**(Big-O는 결국 표기법이라는 것을 잊지 말자!)

> #### 예외적인 상황
![](https://velog.velcdn.com/images/iissk/post/38d4a05f-30a5-43b9-94bc-9b8c509b849c/image.PNG)
이 경우에는 입력값이 서로 다르는 것을 구분하기 위해 O(n)으로 쓰지 않는다.


### 3) O(n²), O(n³)

![](https://velog.velcdn.com/images/iissk/post/c1c6981a-caee-4623-bd46-dff6f17ec3f5/image.png)

2중으로 반복문이 형성이 되어 있다면 그 때의 계산은 제곱으로 양이 늘어날 것이다.
<br>
위의 이미지처럼 n² + n으로 쓰지 않는 것도 무한으로 증가하면 n²만 의미를 갖기 때문이다.

> ##### 반복문이 늘어날 때마다 n의 지수는 증가할 것이다. 하지만 n³ 이상의 표기는 의미가 없어진다.
> ##### 현실적으로 필요한 경우가 없기 때문에 표기하지 않는다.

### 4) log n

![](https://velog.velcdn.com/images/iissk/post/e6383277-d42f-4a9b-905e-9aac7174d55b/image.PNG)

로그는 자료를 찾는 과정을 2로 나눠가면서 찾는 것을 의미한다.
<br>
원하는 정보를 얻기 위해 일일히 인덱스를 확인하는 것이 아닌, 절반씩 소거하며 찾아가는 과정
<br>
위의 예시에서도 기준값을 중심으로 크고, 작고를 2로 나눠가며 찾으면 
<br>
31번의 시행만으로 자료를 찾을 수 있음을 의미한다.

#### O(log n) 은 O(1)과 거의 동일하게 비용 없이 사용이 가능한 방식이다.

<br>

## 4. 배열에서의 Big-O


![](https://velog.velcdn.com/images/iissk/post/7179c114-9227-4947-9af1-a0f2ed4ece3f/image.PNG)

배열 중간에 값을 넣는 경우에는 삽입하는 지점부터 값을 복사해서 새로운 배열에 담는 과정이기에
<br>
O(n)의 비용이 필요한 것이다.

![](https://velog.velcdn.com/images/iissk/post/1febc394-95ad-47fe-b2cc-33e67a9cec62/image.PNG)

배열의 중간을 지우는 과정도 마찬가지로 O(n)의 비용이 필요하다.

> ##### 배열의 인덱스로 찾는 비용은 인덱스만 훑으면서 확인하기 때문에 O(1)
> ##### 배열의 원소를 찾는 비용은 각 인덱스에서 값을 꺼내보는 반복을 해야 하므로 O(n) <br>
> #### ∴ 배열을 찾을 때는 인덱스로 찾는 것이 더 효율성 있는 설계이다.