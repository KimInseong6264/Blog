# 알고리즘과 개발 원칙

## 1. 알고리즘

#### 문제를 해결하기 위한 일련의 과정 및 순서

**알고리즘을 설계하는 과정에서 고려해야 할 것이 Big-O 표기법이다.**


### 1) 알고리즘의 개념

![](https://velog.velcdn.com/images/iissk/post/8c5e944b-d800-44cd-b9e9-c6b208537a3a/image.PNG)

알고리즘의 예시: **라면 조리법**

1. 라면을 끓일 냄비, 조리 도구를 준비
2. 냄비에 물을 넣고 끓인다.
3. 물이 끓으면 면과 스프, 계란을 넣고 3분동안 끓인다.
4. 완성된 라면을 return 한다.

위의 예시처럼 라면을 끓이는 일련의 과정처럼,
<br>
**문제를 해결**하기 위해 **단계적**으로 풀어나가는 **풀이 과정**이라고 할 수 있다.

### 2) 알고리즘 설계 핵심

**알고리즘을 설계할 때, 중요한 것은 총 3가지이다.**

![](https://velog.velcdn.com/images/iissk/post/dafb3d75-2284-417b-a754-d8d999d34f3c/image.png)


1. **가독성:** 문제 해결을 위한 코드인데, 코드 읽는 것부터 문제가 되면 안 된다.
2. **확장성:** 만들어진 알고리즘은 언제든 수정, 보완이 되어야 한다.
3. **효율성:** 한 세월 걸려서 문제를 해결하면 그건 오히려 고문이다...

<br>

## 2. 개발 원칙

#### 1. KISS 원칙( Keep It Simple Stupid )
- 그냥 단순무식하게 유지해라
- 함수 하나에 너무 많은 것을 담지 말아라

#### 2. DRY원칙( Don't Repeat Yourself )
-  중복 코드를 제거하여 효율적으로 작성하라
- 상속, 캡슐화등등

#### 3. YAGNI원칙( You Ain't Goona Need It )
- 지금 필요하지 않은 건 만들지 마라!

### SOLID 원칙


![](https://velog.velcdn.com/images/iissk/post/ddf11840-4014-4961-b16b-99a72058b79e/image.png)

#### SRP (Single Responsibility) 단일 책임 원칙
---
**클래스는 단 하나의 책임만 가져야 한다.**

- 게임 개발영역에서는 지키기가 어렵다.


#### OCP (Open-Closed) 개방-폐쇄 원칙
---
**확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.**

- 추가 작성으로 기능 추가는 하더라도 기존 코드 수정을 요구하지 않도록 구성



#### LSP (Liskov Substitution) 리스코프 치환 원칙
---
**자식 클래스는 부모 클래스를 대체할 수 있어야 한다.**

- 상속 관계에서 부모 클래스와 자식 클래스가 명확하게 연관이 되도록 메서드를 설정하거나 상속관계를 만들어야 한다.
- 다형성 사용시에 코드 터지지 않게 만들어라


#### ISP (Interface Segregation) 인터페이스 분리 원칙
---
**클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다.**

- 인터페이스를 잘 쪼개서 사용해라
- 제약을 너무 주렁주렁 달아서 쓸 필요가 없다.



#### DIP (Dependency Inversion) 의존 역전 원칙
---
**고수준 모듈이 저수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.**

- 객체를 쉽게 교체 할 수 있도록 한다.
- 객체가 객체를 참조, 의존 관계 (클래스에 넣기)를 만들 때, 큰 덩어리의 분류로 객체에 쥐어주기 <br>
    (클래스는 큰 개념을 들고 있고 외부에서 디테일을 추가하는 것) <br>
    ex) 플레이어에게 검, 활 칸 쥐어주지 말고, 무기칸을 쥐어주기
- 유니티에선 중요도가 높은 Solid 원칙



