
# Big-O 표기법

## 1. 알고리즘과 Big-O의 관계

[알고리즘과 개발 원칙](https://kiminseong6264.github.io/Blog/?post=%5B20250925%5D_%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC+%EA%B0%9C%EB%B0%9C+%EC%9B%90%EC%B9%99%5D_%5B%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98+%EA%B8%B8%5D_%5B%5D_%5B%EB%AC%B8%EC%A0%9C%EB%A5%BC+%ED%92%80%EA%B8%B0+%EC%9C%84%ED%95%9C+%EB%AC%B8%EC%A0%9C+%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95%5D_%5B%5D.md)

**알고리즘을 설계하는 과정에서 고려해야 할 것이 Big-O 표기법이다.**
**그렇기 때문에 Big-O를 알기 위해선 먼저 알고리즘에 대해 먼저 알아야 한다.**

#### ∴ 여기서 우리는 효율성 판단을 위해서 Big-O 표기법을 사용하는 것이다.

<br>

## 2. Big-O 표기법

**알고리즘의 효율성을 따질 때는 시간 복잡도(Time Complexity)와 공간 복잡도(pace Complexity)를 고려한다.**

1. **시간 복잡도:** 알고리즘을 사용할 때 들어가는 시간적 비용, 얼마나 빨리 계산할 수 있는지를 의미
2. **공간 복잡도:** 알고리즘에서 사용하는 메모리의 양, 얼마나 적은 공간에서 계산하는지를 의미
<br>
공간 복잡도는 물리적인 한계(하드웨어의 저장공간)가 있어, 주로 알고리즘은 시간 복잡도를 중심으로 효율성을 개선

#### ∴ 시간 복잡도를 표시하는 표기법이 Big-O인 것이다.

### 1) 시간 복잡도(Time Complexity)

![](https://velog.velcdn.com/images/iissk/post/5817a5f3-d792-4dc2-99ec-e7b707ca7aeb/image.png)


시간 복잡도는 위의 3가지의 방식으로 판단을 할 수 있다.
<br>
하지만 프로그래밍에서 중요한 것은 **안정성**이다.
<br>
즉, 최악의 상황을 기준으로 판단했을 때, 안정적인 관리가 가능하다.
<br>
왜 **Big-O**의 **O**가 의미하는 것이 바로 이것이다.

### 2) Big-O 그래프

![](https://velog.velcdn.com/images/iissk/post/0c9ecbb5-6a4f-4117-8a37-e5f88ac0c710/image.PNG)

위의 그림에서와 같이 O( )과 같은 형식으로 표현을 하고 ( ) 안의 값에 따라 시간 복잡도가 달라지는 것을 알 수 있다.

> #### 시간 복잡도의 빠른 정도
> 1 < log < n < 다항함수 < 지수함수 < !(팩토리얼)

<br>

## 3. Big-O의 종류

### 1) O(1)

![](https://velog.velcdn.com/images/iissk/post/ba3ac33b-fc2e-415a-afbb-c5c203a762a9/image.PNG)

O(1)은 반복문이 없는 것으로 생각하면 쉽다. 기본적인 코드 작성들은 O(1)임을 알 수 있다.
<br>
빠르다는 것을 의미한다기 보다는 **비용 없이 사용이 가능하다**는 의미라고 생각하면 된다.

### 2) O(n)

![](https://velog.velcdn.com/images/iissk/post/3f482bd1-e70d-4ff6-b901-b360bfcbd087/image.png)

반복문 중첩없이 사용되는 것을 O(n)이라고 한다.
<br>
위의 그림과 같이 O(2n)으로 쓰지 않고 O(n)으로 쓰지 않는 이유는
<br>
O는 최악을 상정한다고 했기 때문에, **n이 ∞이 되는 것을 기준**으로 생각하면 된다.
<br>
따라서 2n이나 n이나 무한으로 증가하기 때문에 n으로 **표기한다**(Big-O는 결국 표기법이라는 것을 잊지 말자!)

> #### 예외적인 상황
![](https://velog.velcdn.com/images/iissk/post/38d4a05f-30a5-43b9-94bc-9b8c509b849c/image.PNG)
이 경우에는 입력값이 서로 다르는 것을 구분하기 위해 O(n)으로 쓰지 않는다.


### 3) O(n²), O(n³)

![](https://velog.velcdn.com/images/iissk/post/c1c6981a-caee-4623-bd46-dff6f17ec3f5/image.png)

2중으로 반복문이 형성이 되어 있다면 그 때의 계산은 제곱으로 양이 늘어날 것이다.
<br>
위의 이미지처럼 n² + n으로 쓰지 않는 것도 무한으로 증가하면 n²만 의미를 갖기 때문이다.

> ##### 반복문이 늘어날 때마다 n의 지수는 증가할 것이다. 하지만 n³ 이상의 표기는 의미가 없어진다.
> ##### 현실적으로 필요한 경우가 없기 때문에 표기하지 않는다.

### 4) log n

![](https://velog.velcdn.com/images/iissk/post/e6383277-d42f-4a9b-905e-9aac7174d55b/image.PNG)

로그는 자료를 찾는 과정을 2로 나눠가면서 찾는 것을 의미한다.
<br>
원하는 정보를 얻기 위해 일일히 인덱스를 확인하는 것이 아닌, 절반씩 소거하며 찾아가는 과정
<br>
위의 예시에서도 기준값을 중심으로 크고, 작고를 2로 나눠가며 찾으면 
<br>
31번의 시행만으로 자료를 찾을 수 있음을 의미한다.

#### O(log n) 은 O(1)과 거의 동일하게 비용 없이 사용이 가능한 방식이다.

<br>

## 4. 배열에서의 Big-O


![](https://velog.velcdn.com/images/iissk/post/7179c114-9227-4947-9af1-a0f2ed4ece3f/image.PNG)

배열 중간에 값을 넣는 경우에는 삽입하는 지점부터 값을 복사해서 새로운 배열에 담는 과정이기에
<br>
O(n)의 비용이 필요한 것이다.

![](https://velog.velcdn.com/images/iissk/post/1febc394-95ad-47fe-b2cc-33e67a9cec62/image.PNG)

배열의 중간을 지우는 과정도 마찬가지로 O(n)의 비용이 필요하다.

> ##### 배열의 인덱스로 찾는 비용은 인덱스만 훑으면서 확인하기 때문에 O(1)
> ##### 배열의 원소를 찾는 비용은 각 인덱스에서 값을 꺼내보는 반복을 해야 하므로 O(n) <br>
> #### ∴ 배열을 찾을 때는 인덱스로 찾는 것이 더 효율성 있는 설계이다.